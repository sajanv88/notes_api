import { createHttpError } from "./httpError.ts";
import { Cookies } from "./cookies.ts";
import { Response } from "./response.ts";
import { preferredMediaTypes } from "./negotiation/mediaType.ts";
export function createMockApp(state = {}) {
    const app = {
        state,
        use() {
            return app;
        },
        [Symbol.for("Deno.customInspect")]() {
            return "MockApplication {}";
        },
    };
    return app;
}
export const mockContextState = {
    encodingsAccepted: "identity",
};
export function createMockContext({ ip = "127.0.0.1", method = "GET", params, path = "/", state, app = createMockApp(state), headers, } = {}) {
    function createMockRequest() {
        const headerMap = new Headers(headers);
        return {
            accepts(...types) {
                const acceptValue = headerMap.get("Accept");
                if (!acceptValue) {
                    return;
                }
                if (types.length) {
                    return preferredMediaTypes(acceptValue, types)[0];
                }
                return preferredMediaTypes(acceptValue);
            },
            acceptsEncodings() {
                return mockContextState.encodingsAccepted;
            },
            headers: headerMap,
            ip,
            method,
            path,
            search: undefined,
            searchParams: new URLSearchParams(),
            url: new URL(path, "http://localhost/"),
        };
    }
    const request = createMockRequest();
    const response = new Response(request);
    const cookies = new Cookies(request, response);
    return {
        app,
        params,
        request,
        cookies,
        response,
        state: Object.assign({}, app.state),
        assert(condition, errorStatus = 500, message, props) {
            if (condition) {
                return;
            }
            const err = createHttpError(errorStatus, message);
            if (props) {
                Object.assign(err, props);
            }
            throw err;
        },
        throw(errorStatus, message, props) {
            const err = createHttpError(errorStatus, message);
            if (props) {
                Object.assign(err, props);
            }
            throw err;
        },
        [Symbol.for("Deno.customInspect")]() {
            return `MockContext {}`;
        },
    };
}
export function createMockNext() {
    return async function next() { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdGluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRlc3RpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBUUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBR2pELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFFdkMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN6QyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUdqRSxNQUFNLFVBQVUsYUFBYSxDQUczQixRQUFRLEVBQU87SUFFZixNQUFNLEdBQUcsR0FBRztRQUNWLEtBQUs7UUFDTCxHQUFHO1lBQ0QsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDO1FBQ0QsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFDaEMsT0FBTyxvQkFBb0IsQ0FBQztRQUM5QixDQUFDO0tBQ0ssQ0FBQztJQUNULE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQWtCRCxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRztJQUc5QixpQkFBaUIsRUFBRSxVQUFVO0NBQzlCLENBQUM7QUFHRixNQUFNLFVBQVUsaUJBQWlCLENBSy9CLEVBQ0UsRUFBRSxHQUFHLFdBQVcsRUFDaEIsTUFBTSxHQUFHLEtBQUssRUFDZCxNQUFNLEVBQ04sSUFBSSxHQUFHLEdBQUcsRUFDVixLQUFLLEVBQ0wsR0FBRyxHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsRUFDMUIsT0FBTyxNQUNrQixFQUFFO0lBRTdCLFNBQVMsaUJBQWlCO1FBQ3hCLE1BQU0sU0FBUyxHQUFHLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3ZDLE9BQU87WUFDTCxPQUFPLENBQUMsR0FBRyxLQUFlO2dCQUN4QixNQUFNLFdBQVcsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUM1QyxJQUFJLENBQUMsV0FBVyxFQUFFO29CQUNoQixPQUFPO2lCQUNSO2dCQUNELElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtvQkFDaEIsT0FBTyxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ25EO2dCQUNELE9BQU8sbUJBQW1CLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDMUMsQ0FBQztZQUNELGdCQUFnQjtnQkFDZCxPQUFPLGdCQUFnQixDQUFDLGlCQUFpQixDQUFDO1lBQzVDLENBQUM7WUFDRCxPQUFPLEVBQUUsU0FBUztZQUNsQixFQUFFO1lBQ0YsTUFBTTtZQUNOLElBQUk7WUFDSixNQUFNLEVBQUUsU0FBUztZQUNqQixZQUFZLEVBQUUsSUFBSSxlQUFlLEVBQUU7WUFDbkMsR0FBRyxFQUFFLElBQUksR0FBRyxDQUFDLElBQUksRUFBRSxtQkFBbUIsQ0FBQztTQUNqQyxDQUFDO0lBQ1gsQ0FBQztJQUVELE1BQU0sT0FBTyxHQUFHLGlCQUFpQixFQUFFLENBQUM7SUFDcEMsTUFBTSxRQUFRLEdBQUcsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdkMsTUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRS9DLE9BQVE7UUFDTixHQUFHO1FBQ0gsTUFBTTtRQUNOLE9BQU87UUFDUCxPQUFPO1FBQ1AsUUFBUTtRQUNSLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDO1FBQ25DLE1BQU0sQ0FDSixTQUFjLEVBQ2QsY0FBMkIsR0FBRyxFQUM5QixPQUFnQixFQUNoQixLQUErQjtZQUUvQixJQUFJLFNBQVMsRUFBRTtnQkFDYixPQUFPO2FBQ1I7WUFDRCxNQUFNLEdBQUcsR0FBRyxlQUFlLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ2xELElBQUksS0FBSyxFQUFFO2dCQUNULE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQzNCO1lBQ0QsTUFBTSxHQUFHLENBQUM7UUFDWixDQUFDO1FBQ0QsS0FBSyxDQUNILFdBQXdCLEVBQ3hCLE9BQWdCLEVBQ2hCLEtBQStCO1lBRS9CLE1BQU0sR0FBRyxHQUFHLGVBQWUsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDbEQsSUFBSSxLQUFLLEVBQUU7Z0JBQ1QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7YUFDM0I7WUFDRCxNQUFNLEdBQUcsQ0FBQztRQUNaLENBQUM7UUFDRCxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsb0JBQW9CLENBQUMsQ0FBQztZQUNoQyxPQUFPLGdCQUFnQixDQUFDO1FBQzFCLENBQUM7S0FDb0MsQ0FBQztBQUMxQyxDQUFDO0FBSUQsTUFBTSxVQUFVLGNBQWM7SUFDNUIsT0FBTyxLQUFLLFVBQVUsSUFBSSxLQUFJLENBQUMsQ0FBQztBQUNsQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTgtMjAyMSB0aGUgb2FrIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuXG4vLyBkZW5vLWxpbnQtaWdub3JlLWZpbGUgbm8tZXhwbGljaXQtYW55XG5cbi8vIEEgbW9kdWxlIG9mIHV0aWxpdHkgZnVuY3Rpb25zIHdoaWNoIGNhbiBtYWtlIHRlc3RpbmcgYW4gb2FrIGFwcGxpY2F0aW9uXG4vLyBlYXNpZXIuXG5cbmltcG9ydCB0eXBlIHsgQXBwbGljYXRpb24sIFN0YXRlIH0gZnJvbSBcIi4vYXBwbGljYXRpb24udHNcIjtcbmltcG9ydCB7IGNyZWF0ZUh0dHBFcnJvciB9IGZyb20gXCIuL2h0dHBFcnJvci50c1wiO1xuaW1wb3J0IHR5cGUgeyBSb3V0ZVBhcmFtcywgUm91dGVyQ29udGV4dCB9IGZyb20gXCIuL3JvdXRlci50c1wiO1xuaW1wb3J0IHR5cGUgeyBFcnJvclN0YXR1cyB9IGZyb20gXCIuL3R5cGVzLmQudHNcIjtcbmltcG9ydCB7IENvb2tpZXMgfSBmcm9tIFwiLi9jb29raWVzLnRzXCI7XG5pbXBvcnQgeyBSZXF1ZXN0IH0gZnJvbSBcIi4vcmVxdWVzdC50c1wiO1xuaW1wb3J0IHsgUmVzcG9uc2UgfSBmcm9tIFwiLi9yZXNwb25zZS50c1wiO1xuaW1wb3J0IHsgcHJlZmVycmVkTWVkaWFUeXBlcyB9IGZyb20gXCIuL25lZ290aWF0aW9uL21lZGlhVHlwZS50c1wiO1xuXG4vKiogQ3JlYXRlcyBhIG1vY2sgb2YgYEFwcGxpY2F0aW9uYC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNb2NrQXBwPFxuICBTIGV4dGVuZHMgUmVjb3JkPHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgYW55PiA9IFJlY29yZDxzdHJpbmcsIGFueT4sXG4+KFxuICBzdGF0ZSA9IHt9IGFzIFMsXG4pOiBBcHBsaWNhdGlvbjxTPiB7XG4gIGNvbnN0IGFwcCA9IHtcbiAgICBzdGF0ZSxcbiAgICB1c2UoKSB7XG4gICAgICByZXR1cm4gYXBwO1xuICAgIH0sXG4gICAgW1N5bWJvbC5mb3IoXCJEZW5vLmN1c3RvbUluc3BlY3RcIildKCkge1xuICAgICAgcmV0dXJuIFwiTW9ja0FwcGxpY2F0aW9uIHt9XCI7XG4gICAgfSxcbiAgfSBhcyBhbnk7XG4gIHJldHVybiBhcHA7XG59XG5cbi8qKiBPcHRpb25zIHRoYXQgY2FuIGJlIHNldCBpbiBhIG1vY2sgY29udGV4dC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9ja0NvbnRleHRPcHRpb25zPFxuICBSIGV4dGVuZHMgc3RyaW5nLFxuICBQIGV4dGVuZHMgUm91dGVQYXJhbXM8Uj4gPSBSb3V0ZVBhcmFtczxSPixcbiAgUyBleHRlbmRzIFN0YXRlID0gUmVjb3JkPHN0cmluZywgYW55Pixcbj4ge1xuICBhcHA/OiBBcHBsaWNhdGlvbjxTPjtcbiAgaXA/OiBzdHJpbmc7XG4gIG1ldGhvZD86IHN0cmluZztcbiAgcGFyYW1zPzogUDtcbiAgcGF0aD86IHN0cmluZztcbiAgc3RhdGU/OiBTO1xuICBoZWFkZXJzPzogW3N0cmluZywgc3RyaW5nXVtdO1xufVxuXG4vKiogQWxsb3dzIGV4dGVybmFsIHBhcnRpZXMgdG8gbW9kaWZ5IHRoZSBjb250ZXh0IHN0YXRlLiAqL1xuZXhwb3J0IGNvbnN0IG1vY2tDb250ZXh0U3RhdGUgPSB7XG4gIC8qKiBBZGp1c3RzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGBhY2NlcHRlZEVuY29kaW5nc2AgaW4gdGhlIGNvbnRleHQnc1xuICAgKiBgcmVxdWVzdGAgb2JqZWN0LiAqL1xuICBlbmNvZGluZ3NBY2NlcHRlZDogXCJpZGVudGl0eVwiLFxufTtcblxuLyoqIENyZWF0ZSBhIG1vY2sgb2YgYENvbnRleHRgIG9yIGBSb3V0ZXJDb250ZXh0YC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNb2NrQ29udGV4dDxcbiAgUiBleHRlbmRzIHN0cmluZyxcbiAgUCBleHRlbmRzIFJvdXRlUGFyYW1zPFI+ID0gUm91dGVQYXJhbXM8Uj4sXG4gIFMgZXh0ZW5kcyBTdGF0ZSA9IFJlY29yZDxzdHJpbmcsIGFueT4sXG4+KFxuICB7XG4gICAgaXAgPSBcIjEyNy4wLjAuMVwiLFxuICAgIG1ldGhvZCA9IFwiR0VUXCIsXG4gICAgcGFyYW1zLFxuICAgIHBhdGggPSBcIi9cIixcbiAgICBzdGF0ZSxcbiAgICBhcHAgPSBjcmVhdGVNb2NrQXBwKHN0YXRlKSxcbiAgICBoZWFkZXJzLFxuICB9OiBNb2NrQ29udGV4dE9wdGlvbnM8Uj4gPSB7fSxcbikge1xuICBmdW5jdGlvbiBjcmVhdGVNb2NrUmVxdWVzdCgpOiBSZXF1ZXN0IHtcbiAgICBjb25zdCBoZWFkZXJNYXAgPSBuZXcgSGVhZGVycyhoZWFkZXJzKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjZXB0cyguLi50eXBlczogc3RyaW5nW10pIHtcbiAgICAgICAgY29uc3QgYWNjZXB0VmFsdWUgPSBoZWFkZXJNYXAuZ2V0KFwiQWNjZXB0XCIpO1xuICAgICAgICBpZiAoIWFjY2VwdFZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZmVycmVkTWVkaWFUeXBlcyhhY2NlcHRWYWx1ZSwgdHlwZXMpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVmZXJyZWRNZWRpYVR5cGVzKGFjY2VwdFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBhY2NlcHRzRW5jb2RpbmdzKCkge1xuICAgICAgICByZXR1cm4gbW9ja0NvbnRleHRTdGF0ZS5lbmNvZGluZ3NBY2NlcHRlZDtcbiAgICAgIH0sXG4gICAgICBoZWFkZXJzOiBoZWFkZXJNYXAsXG4gICAgICBpcCxcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhdGgsXG4gICAgICBzZWFyY2g6IHVuZGVmaW5lZCxcbiAgICAgIHNlYXJjaFBhcmFtczogbmV3IFVSTFNlYXJjaFBhcmFtcygpLFxuICAgICAgdXJsOiBuZXcgVVJMKHBhdGgsIFwiaHR0cDovL2xvY2FsaG9zdC9cIiksXG4gICAgfSBhcyBhbnk7XG4gIH1cblxuICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlTW9ja1JlcXVlc3QoKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UocmVxdWVzdCk7XG4gIGNvbnN0IGNvb2tpZXMgPSBuZXcgQ29va2llcyhyZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgcmV0dXJuICh7XG4gICAgYXBwLFxuICAgIHBhcmFtcyxcbiAgICByZXF1ZXN0LFxuICAgIGNvb2tpZXMsXG4gICAgcmVzcG9uc2UsXG4gICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oe30sIGFwcC5zdGF0ZSksXG4gICAgYXNzZXJ0KFxuICAgICAgY29uZGl0aW9uOiBhbnksXG4gICAgICBlcnJvclN0YXR1czogRXJyb3JTdGF0dXMgPSA1MDAsXG4gICAgICBtZXNzYWdlPzogc3RyaW5nLFxuICAgICAgcHJvcHM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICApOiBhc3NlcnRzIGNvbmRpdGlvbiB7XG4gICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVyciA9IGNyZWF0ZUh0dHBFcnJvcihlcnJvclN0YXR1cywgbWVzc2FnZSk7XG4gICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlcnIsIHByb3BzKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9LFxuICAgIHRocm93KFxuICAgICAgZXJyb3JTdGF0dXM6IEVycm9yU3RhdHVzLFxuICAgICAgbWVzc2FnZT86IHN0cmluZyxcbiAgICAgIHByb3BzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgKTogbmV2ZXIge1xuICAgICAgY29uc3QgZXJyID0gY3JlYXRlSHR0cEVycm9yKGVycm9yU3RhdHVzLCBtZXNzYWdlKTtcbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGVyciwgcHJvcHMpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH0sXG4gICAgW1N5bWJvbC5mb3IoXCJEZW5vLmN1c3RvbUluc3BlY3RcIildKCkge1xuICAgICAgcmV0dXJuIGBNb2NrQ29udGV4dCB7fWA7XG4gICAgfSxcbiAgfSBhcyB1bmtub3duKSBhcyBSb3V0ZXJDb250ZXh0PFIsIFAsIFM+O1xufVxuXG4vKiogQ3JlYXRlcyBhIG1vY2sgYG5leHQoKWAgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgd2hlbiBjYWxsaW5nXG4gKiBtaWRkbGV3YXJlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1vY2tOZXh0KCkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gbmV4dCgpIHt9O1xufVxuIl19